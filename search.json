[
  {
    "objectID": "hands-on.html",
    "href": "hands-on.html",
    "title": "Hands-on DuckDB & dplyr",
    "section": "",
    "text": "Loading the necessary packages. DuckDB has its own R package that is mostly a wrapper around dbplyr and DBI\nlibrary(tidyverse)\nlibrary(dbplyr)       # to query databases in a tidyverse style manner\nlibrary(DBI)          # to connect to databases\n# install.packages(\"duckdb\")  # install this package to get duckDB API\nlibrary(duckdb)       # Specific to duckDB"
  },
  {
    "objectID": "hands-on.html#the-dataset",
    "href": "hands-on.html#the-dataset",
    "title": "Hands-on DuckDB & dplyr",
    "section": "The dataset",
    "text": "The dataset\nARCTIC SHOREBIRD DEMOGRAPHICS NETWORK https://doi.org/10.18739/A2222R68W\nData set hosted by the NSF Arctic Data Center (https://arcticdata.io)\nField data on shorebird ecology and environmental conditions were collected from 1993-2014 at 16 field sites in Alaska, Canada, and Russia.\nData were not collected in every year at all sites. Studies of the population ecology of these birds included nest-monitoring to determine timing of reproduction and reproductive success; live capture of birds to collect blood samples, feathers, and fecal samples for investigations of population structure and pathogens; banding of birds to determine annual survival rates; resighting of color-banded birds to determine space use and site fidelity; and use of light-sensitive geolocators to investigate migratory movements. Data on climatic conditions, prey abundance, and predators were also collected. Environmental data included weather stations that recorded daily climatic conditions, surveys of seasonal snowmelt, weekly sampling of terrestrial and aquatic invertebrates that are prey of shorebirds, live trapping of small mammals (alternate prey for shorebird predators), and daily counts of potential predators (jaegers, falcons, foxes). Detailed field methods for each year are available in the ASDN_protocol_201X.pdf files. All research was conducted under permits from relevant federal, state and university authorities.\nSee 01_ASDN_Readme.txt provided in the data folder for full metadata information about this data set."
  },
  {
    "objectID": "hands-on.html#analyzing-the-bird-dataset-using-csv-files-raw-data",
    "href": "hands-on.html#analyzing-the-bird-dataset-using-csv-files-raw-data",
    "title": "Hands-on DuckDB & dplyr",
    "section": "Analyzing the bird dataset using csv files (raw data)",
    "text": "Analyzing the bird dataset using csv files (raw data)\nLet us import the csv files with the species information:\n\n# Import the species\nspecies_csv &lt;- read_csv(\"data/species.csv\")\n\nglimpse(species_csv)\n\nRows: 99\nColumns: 4\n$ Code            &lt;chr&gt; \"agsq\", \"amcr\", \"amgp\", \"arfo\", \"arte\", \"basa\", \"bbis\"…\n$ Common_name     &lt;chr&gt; \"Arctic ground squirrel\", \"American Crow\", \"American G…\n$ Scientific_name &lt;chr&gt; \"Spermophilus parryii\", \"Corvus brachyrhynchos\", \"Pluv…\n$ Relevance       &lt;chr&gt; \"Potential predator (eggs; mammal)\", \"Potential predat…\n\n\nLet’s explore what is in the Relevance attribute/column:\n\nspecies_csv %&gt;% \n  group_by(Relevance) %&gt;%\n  count()\n\n# A tibble: 7 × 2\n# Groups:   Relevance [7]\n  Relevance                                    n\n  &lt;chr&gt;                                    &lt;int&gt;\n1 Incidental monitoring                       18\n2 Microtine (alternate prey for predators)     5\n3 Potential predator (avian)                  25\n4 Potential predator (eggs; mammal)            2\n5 Potential predator (mammal)                  6\n6 Study species                               41\n7 Study species; potential predator (eggs)     2\n\n\nWe are interested in the Study species because according to the metadata they are the species that are included in the data sets for banding, resighting, and/or nest monitoring. Let us extract the species and sort them in alphabetical order:\n\n# list of the bird species included in the study\nspecies_csv %&gt;%\n  filter(Relevance==\"Study species\") %&gt;%\n  select(Scientific_name) %&gt;%\n  arrange(Scientific_name)\n\n# A tibble: 41 × 1\n   Scientific_name     \n   &lt;chr&gt;               \n 1 Actitis macularius  \n 2 Calidris acuminata  \n 3 Calidris alba       \n 4 Calidris alpina     \n 5 Calidris bairdii    \n 6 Calidris canutus    \n 7 Calidris falcinellus\n 8 Calidris ferruginea \n 9 Calidris fuscicollis\n10 Calidris himantopus \n# ℹ 31 more rows\n\n\nNow we can load more information about the sites, nests, and eggs monitoring\n\nsites_csv &lt;- read_csv(\"data/site.csv\")\n\nnests_csv &lt;- read_csv(\"data/ASDN_Bird_nests.csv\")\n\neggs_csv &lt;- read_csv(\"data/ASDN_Bird_eggs.csv\")"
  },
  {
    "objectID": "hands-on.html#lets-connect-to-our-first-database",
    "href": "hands-on.html#lets-connect-to-our-first-database",
    "title": "Hands-on DuckDB & dplyr",
    "section": "Let’s connect to our first database",
    "text": "Let’s connect to our first database\n\nLoad the bird database\nThis database has been built from the csv files we just manipulated, so the data should be very similar - note we did not say identical more on this in the last section:\n\nconn &lt;- dbConnect(duckdb::duckdb(), dbdir = \"./data/bird_database.duckdb\", read_only = FALSE)\n\n\n\nLet’s try to reproduce the analaysis we just did\n\nspecies &lt;- tbl(conn, \"Species\")\nspecies\n\n# Source:   table&lt;Species&gt; [?? x 4]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1015-azure:R 4.3.3/./data/bird_database.duckdb]\n   Code  Common_name             Scientific_name        Relevance               \n   &lt;chr&gt; &lt;chr&gt;                   &lt;chr&gt;                  &lt;chr&gt;                   \n 1 agsq  Arctic ground squirrel  Spermophilus parryii   Potential predator (egg…\n 2 amcr  American Crow           Corvus brachyrhynchos  Potential predator (avi…\n 3 amgp  American Golden-Plover  Pluvialis dominica     Study species           \n 4 arfo  Arctic fox              Alopex lagopus         Potential predator (mam…\n 5 arte  Arctic Tern             Sterna paradisaea      Incidental monitoring   \n 6 basa  Baird's Sandpiper       Calidris bairdii       Study species           \n 7 bbis  Broad-billed Sandpiper  Calidris falcinellus   Study species           \n 8 bbpl  Black-bellied Plover    Pluvialis squatarola   Study species           \n 9 bbsa  Buff-breasted Sandpiper Calidris subruficollis Study species           \n10 besw  Bewick's Swan           Cygnus columbianus     Incidental monitoring   \n# ℹ more rows\n\n\n\nspecies %&gt;%\n  filter(Relevance==\"Study species\") %&gt;%\n  select(Scientific_name) %&gt;%\n  arrange(Scientific_name) %&gt;%\n  head(3)\n\n# Source:     SQL [3 x 1]\n# Database:   DuckDB v0.9.2 [unknown@Linux 6.5.0-1015-azure:R 4.3.3/./data/bird_database.duckdb]\n# Ordered by: Scientific_name\n  Scientific_name   \n  &lt;chr&gt;             \n1 Actitis macularius\n2 Calidris acuminata\n3 Calidris alba     \n\n\nNote that those are not dataframes but tables. What dbplyr is actually doing behind the scenes is translating all those dplyr operations into SQL, sending the SQL to the database, retrieving results, etc.\n\nHow can I get a “real dataframe?”\nyou add collect() to your query.\n\nspecies %&gt;%\n  filter(Relevance==\"Study species\") %&gt;%\n  select(Scientific_name) %&gt;%\n  arrange(Scientific_name) %&gt;%\n  head(3) %&gt;% \n  collect()\n\n# A tibble: 3 × 1\n  Scientific_name   \n  &lt;chr&gt;             \n1 Actitis macularius\n2 Calidris acuminata\n3 Calidris alba     \n\n\nNote it means the full query is going to be ran and save in you memory. This might slow things down so you generally want to collect on the smallest data frame you can\n\n\nHow can you see the SQL query equivalent to the tidyverse code?\n\n# Add show_query() to the end to see what SQL it is sending!\nspecies %&gt;%\n  filter(Relevance==\"Study species\") %&gt;%\n  select(Scientific_name) %&gt;%\n  arrange(Scientific_name) %&gt;%\n  head(3) %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT Scientific_name\nFROM Species\nWHERE (Relevance = 'Study species')\nORDER BY Scientific_name\nLIMIT 3\n\n\nThis is a great way to start getting familiar with the SQL syntax, because although you can do a lot with dbplyr you can not do everything that SQL can do. So at some point you might want to start using SQL directly.\nHere is how you could run the query using the SQL code directly\n\n# Establish a set of Parquet files\ndbGetQuery(conn, \"SELECT Scientific_name FROM Species WHERE (Relevance = 'Study species') ORDER BY Scientific_name LIMIT 3\")\n\n     Scientific_name\n1 Actitis macularius\n2 Calidris acuminata\n3      Calidris alba\n\n\nYou can do pretty much anything with these quasi-tables, including grouping, summarization, joins, etc.\nLet’s count how many species there are per Relevance categories:\n\nspecies %&gt;%\n  group_by(Relevance) %&gt;%\n  summarize(num_species = n())\n\n# Source:   SQL [7 x 2]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1015-azure:R 4.3.3/./data/bird_database.duckdb]\n  Relevance                                num_species\n  &lt;chr&gt;                                          &lt;dbl&gt;\n1 Potential predator (eggs; mammal)                  2\n2 Microtine (alternate prey for predators)           5\n3 Study species                                     41\n4 Incidental monitoring                             18\n5 Potential predator (avian)                        25\n6 Potential predator (mammal)                        6\n7 Study species; potential predator (eggs)           2\n\n\nDoes that code looks familiar? But this time, here is really the query that was used to retrieve this information:\n\nspecies %&gt;%\n  group_by(Relevance) %&gt;%\n  summarize(num_species = n()) %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT Relevance, COUNT(*) AS num_species\nFROM Species\nGROUP BY Relevance\n\n\n\nspecies %&gt;%\n  mutate(Code = paste(\"X\", Code)) %&gt;%\n  head()\n\n# Source:   SQL [6 x 4]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1015-azure:R 4.3.3/./data/bird_database.duckdb]\n  Code   Common_name            Scientific_name       Relevance                 \n  &lt;chr&gt;  &lt;chr&gt;                  &lt;chr&gt;                 &lt;chr&gt;                     \n1 X agsq Arctic ground squirrel Spermophilus parryii  Potential predator (eggs;…\n2 X amcr American Crow          Corvus brachyrhynchos Potential predator (avian)\n3 X amgp American Golden-Plover Pluvialis dominica    Study species             \n4 X arfo Arctic fox             Alopex lagopus        Potential predator (mamma…\n5 X arte Arctic Tern            Sterna paradisaea     Incidental monitoring     \n6 X basa Baird's Sandpiper      Calidris bairdii      Study species             \n\n\n\nspecies %&gt;%\n  mutate(Code = paste(\"X\", Code)) %&gt;%\n  head() %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  CONCAT_WS(' ', 'X', Code) AS Code,\n  Common_name,\n  Scientific_name,\n  Relevance\nFROM Species\nLIMIT 6\n\n\nLimitation: no way to add or update data, dbplyr is view only. If you want to add or update data, you’ll need to use the DBI package functions.\n\n\n\nDisconnecting from the database\nBefore we close our session, it is good practice to disconnect from the database first\n\nDBI::dbDisconnect(conn, shutdown = TRUE)"
  },
  {
    "objectID": "hands-on.html#how-did-we-create-this-database",
    "href": "hands-on.html#how-did-we-create-this-database",
    "title": "Hands-on DuckDB & dplyr",
    "section": "How did we create this database",
    "text": "How did we create this database\nYou might be wondering, how we created this database from our csv files. Most databases have some function to help you import csv files into databases. Note that since there is not data modeling (does not have to be normalized or tidy) constraints nor data type constraints a lot things can go wrong. This is a great opportunity to implement a QA/QC on your data and help you to keep clean and tidy moving forward as new data are collected."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About RDS",
    "section": "",
    "text": "Research Data Services (RDS) helps UCSB researchers manage and preserve their research data through:\n\nConsultations\nLong-term engagements\nInstructional workshops\n\nOur team offers support across the research data lifecycle, from pre-project planning to post-project archival, connecting researchers with both locally- and externally-provided curation services. Our goal is to ensure that all research data is well-described, FAIR (Findable, Accessible, Interoperable, Reusable), and sustainably preservable, and that researchers receive scholarly credit for sharing and publishing data.\nContact us if you have any questions: rds@library.ucsb.edu"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Integrating SQL into R analytical workflows using duckDB & dbplyr",
    "section": "",
    "text": "Why consider a database\nExample of the birds dataset with multiple csv files and relationships\nPros & Cons of databases\nServer vs personal database\ndbplyr to connect to the R world"
  },
  {
    "objectID": "index.html#slides",
    "href": "index.html#slides",
    "title": "Integrating SQL into R analytical workflows using duckDB & dbplyr",
    "section": "",
    "text": "Why consider a database\nExample of the birds dataset with multiple csv files and relationships\nPros & Cons of databases\nServer vs personal database\ndbplyr to connect to the R world"
  },
  {
    "objectID": "index.html#hands-on",
    "href": "index.html#hands-on",
    "title": "Integrating SQL into R analytical workflows using duckDB & dbplyr",
    "section": "Hands-on",
    "text": "Hands-on\n\nHow to connect to a database from R\nHow to query a database using dbplyr\nHow to see the SQL code behind a tidyverse workflow\nHow to directly use SQL from R\n\nWrap-up"
  }
]