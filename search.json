[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About RDS",
    "section": "",
    "text": "Research Data Services (RDS) helps UCSB researchers manage and preserve their research data through:\n\nConsultations\nLong-term engagements\nInstructional workshops\n\nOur team offers support across the research data lifecycle, from pre-project planning to post-project archival, connecting researchers with both locally- and externally-provided curation services. Our goal is to ensure that all research data is well-described, FAIR (Findable, Accessible, Interoperable, Reusable), and sustainably preservable, and that researchers receive scholarly credit for sharing and publishing data.\nContact us if you have any questions: rds@library.ucsb.edu"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Integrating SQL into R analytical workflows using duckDB & dbplyr",
    "section": "",
    "text": "Why consider a database\nExample of the birds dataset with multiple csv files and relationships\nPros & Cons of databases\nServer vs personal database\ndbplyr to connect to the R world"
  },
  {
    "objectID": "index.html#slides",
    "href": "index.html#slides",
    "title": "Integrating SQL into R analytical workflows using duckDB & dbplyr",
    "section": "",
    "text": "Why consider a database\nExample of the birds dataset with multiple csv files and relationships\nPros & Cons of databases\nServer vs personal database\ndbplyr to connect to the R world"
  },
  {
    "objectID": "index.html#hands-on",
    "href": "index.html#hands-on",
    "title": "Integrating SQL into R analytical workflows using duckDB & dbplyr",
    "section": "Hands-on",
    "text": "Hands-on\n\nHow to connect to a database from R\nHow to query a database using dbplyr\nHow to see the SQL code behind a tidyverse workflow\nHow to directly use SQL from R\n\nWrap-up"
  },
  {
    "objectID": "hands-on.html",
    "href": "hands-on.html",
    "title": "Hands-on DuckDB & dplyr",
    "section": "",
    "text": "ARCTIC SHOREBIRD DEMOGRAPHICS NETWORK https://doi.org/10.18739/A2222R68W\nData set hosted by the NSF Arctic Data Center (https://arcticdata.io)\nField data on shorebird ecology and environmental conditions were collected from 1993-2014 at 16 field sites in Alaska, Canada, and Russia.\n\n\n\nShorebird, copyright NYT\n\n\nData were not collected in every year at all sites. Studies of the population ecology of these birds included nest-monitoring to determine timing of reproduction and reproductive success; live capture of birds to collect blood samples, feathers, and fecal samples for investigations of population structure and pathogens; banding of birds to determine annual survival rates; resighting of color-banded birds to determine space use and site fidelity; and use of light-sensitive geolocators to investigate migratory movements. Data on climatic conditions, prey abundance, and predators were also collected. Environmental data included weather stations that recorded daily climatic conditions, surveys of seasonal snowmelt, weekly sampling of terrestrial and aquatic invertebrates that are prey of shorebirds, live trapping of small mammals (alternate prey for shorebird predators), and daily counts of potential predators (jaegers, falcons, foxes). Detailed field methods for each year are available in the ASDN_protocol_201X.pdf files. All research was conducted under permits from relevant federal, state and university authorities.\nSee 01_ASDN_Readme.txt provided in the data folder for full metadata information about this data set."
  },
  {
    "objectID": "hands-on.html#the-dataset",
    "href": "hands-on.html#the-dataset",
    "title": "Hands-on DuckDB & dplyr",
    "section": "",
    "text": "ARCTIC SHOREBIRD DEMOGRAPHICS NETWORK https://doi.org/10.18739/A2222R68W\nData set hosted by the NSF Arctic Data Center (https://arcticdata.io)\nField data on shorebird ecology and environmental conditions were collected from 1993-2014 at 16 field sites in Alaska, Canada, and Russia.\n\n\n\nShorebird, copyright NYT\n\n\nData were not collected in every year at all sites. Studies of the population ecology of these birds included nest-monitoring to determine timing of reproduction and reproductive success; live capture of birds to collect blood samples, feathers, and fecal samples for investigations of population structure and pathogens; banding of birds to determine annual survival rates; resighting of color-banded birds to determine space use and site fidelity; and use of light-sensitive geolocators to investigate migratory movements. Data on climatic conditions, prey abundance, and predators were also collected. Environmental data included weather stations that recorded daily climatic conditions, surveys of seasonal snowmelt, weekly sampling of terrestrial and aquatic invertebrates that are prey of shorebirds, live trapping of small mammals (alternate prey for shorebird predators), and daily counts of potential predators (jaegers, falcons, foxes). Detailed field methods for each year are available in the ASDN_protocol_201X.pdf files. All research was conducted under permits from relevant federal, state and university authorities.\nSee 01_ASDN_Readme.txt provided in the data folder for full metadata information about this data set."
  },
  {
    "objectID": "hands-on.html#analyzing-the-bird-dataset-using-csv-files-raw-data",
    "href": "hands-on.html#analyzing-the-bird-dataset-using-csv-files-raw-data",
    "title": "Hands-on DuckDB & dplyr",
    "section": "Analyzing the bird dataset using csv files (raw data)",
    "text": "Analyzing the bird dataset using csv files (raw data)\nLoading the necessary packages. DuckDB has its own R package that is mostly a wrapper around dbplyr and DBI.\n\nlibrary(tidyverse)\nlibrary(dbplyr)       # to query databases in a tidyverse style manner\nlibrary(DBI)          # to connect to databases\n# install.packages(\"duckdb\")  # install this package to get duckDB API\nlibrary(duckdb)       # Specific to duckDB\n\nImport the csv files with the bird species information:\n\n# Import the species\nspecies_csv &lt;- read_csv(\"data/species.csv\")\n\nglimpse(species_csv)\n\nRows: 99\nColumns: 4\n$ Code            &lt;chr&gt; \"agsq\", \"amcr\", \"amgp\", \"arfo\", \"arte\", \"basa\", \"bbis\"…\n$ Common_name     &lt;chr&gt; \"Arctic ground squirrel\", \"American Crow\", \"American G…\n$ Scientific_name &lt;chr&gt; \"Spermophilus parryii\", \"Corvus brachyrhynchos\", \"Pluv…\n$ Relevance       &lt;chr&gt; \"Potential predator (eggs; mammal)\", \"Potential predat…\n\n\nLet’s explore what is in the Relevance attribute/column:\n\nspecies_csv %&gt;% \n  group_by(Relevance) %&gt;%\n  summarize(num_species = n())\n\n# A tibble: 7 × 2\n  Relevance                                num_species\n  &lt;chr&gt;                                          &lt;int&gt;\n1 Incidental monitoring                             18\n2 Microtine (alternate prey for predators)           5\n3 Potential predator (avian)                        25\n4 Potential predator (eggs; mammal)                  2\n5 Potential predator (mammal)                        6\n6 Study species                                     41\n7 Study species; potential predator (eggs)           2\n\n\nWe are interested in the Study species because according to the metadata, they are the species that are included in the data sets for banding, resighting, and/or nest monitoring.\nLet us extract the species and sort them in alphabetical order:\n\n# list of the bird species included in the study\nspecies_study &lt;- species_csv %&gt;%\n  filter(Relevance==\"Study species\") %&gt;%\n  select(Scientific_name, Code) %&gt;%\n  arrange(Scientific_name)\n\nspecies_study\n\n# A tibble: 41 × 2\n   Scientific_name      Code \n   &lt;chr&gt;                &lt;chr&gt;\n 1 Actitis macularius   spsa \n 2 Calidris acuminata   spts \n 3 Calidris alba        sand \n 4 Calidris alpina      dunl \n 5 Calidris bairdii     basa \n 6 Calidris canutus     rekn \n 7 Calidris falcinellus bbis \n 8 Calidris ferruginea  cusa \n 9 Calidris fuscicollis wrsa \n10 Calidris himantopus  stsa \n# ℹ 31 more rows\n\n\n\nAverage egg volume\n\n\n\n\n\n\nAnalysis\n\n\n\nWe would like to know what is the average egg size for each of those bird species. How would we do that?\n\n\nWe will need more information that what we have in our species table. Actually we will need to also retrieve information from the nests and eggs monitoring table.\nAn egg is in a nest, and a nest is associated with a species\n\n# information about the nests\nnests_csv &lt;- read_csv(\"data/ASDN_Bird_nests.csv\")\n\n# information about the \neggs_csv &lt;- read_csv(\"data/ASDN_Bird_eggs.csv\")\n\nHow do we join those tables?\n\nglimpse(eggs_csv)\n\nRows: 406\nColumns: 7\n$ Book_page &lt;chr&gt; \"b14.6\", \"b14.6\", \"b14.6\", \"b14.6\", \"b14.6\", \"b14.6\", \"b14.6…\n$ Year      &lt;dbl&gt; 2014, 2014, 2014, 2014, 2014, 2014, 2014, 2014, 2014, 2014, …\n$ Site      &lt;chr&gt; \"eaba\", \"eaba\", \"eaba\", \"eaba\", \"eaba\", \"eaba\", \"eaba\", \"eab…\n$ Nest_ID   &lt;chr&gt; \"14eabaage01\", \"14eabaage01\", \"14eabaage01\", \"14eabaagl01\", …\n$ Egg_num   &lt;dbl&gt; 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, …\n$ Length    &lt;dbl&gt; 39.14, 41.51, 48.29, 47.56, 48.13, 49.62, 47.16, 51.07, 48.7…\n$ Width     &lt;dbl&gt; 33.00, 33.39, 33.40, 32.36, 32.40, 32.40, 34.44, 32.22, 34.6…\n\n\nNest_Id seems like promising as a foreign key!!\n\nglimpse(nests_csv)\n\nRows: 1,547\nColumns: 11\n$ Book_page  &lt;chr&gt; \"b14.6\", \"b11.7\", \"b11.6\", \"b11.6\", \"b11.6\", \"b11.7\", \"b11.…\n$ Year       &lt;dbl&gt; 2014, 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011, 2011,…\n$ Site       &lt;chr&gt; \"chur\", \"eaba\", \"eaba\", \"eaba\", \"eaba\", \"eaba\", \"eaba\", \"ea…\n$ Nest_ID    &lt;chr&gt; \"14HPE1\", \"11eaba\", \"11eabaagc01\", \"11eabaagv01\", \"11eababb…\n$ Species    &lt;chr&gt; \"sepl\", \"wrsa\", \"amgp\", \"amgp\", \"bbpl\", \"wrsa\", \"dunl\", \"du…\n$ Observer   &lt;chr&gt; \"vloverti\", \"bhill\", \"dkessler\", \"dkessler\", \"dkessler\", \"b…\n$ Date_found &lt;date&gt; 2014-06-14, 2011-07-10, 2011-06-24, 2011-06-25, 2011-06-24…\n$ how_found  &lt;chr&gt; NA, \"searcher\", \"searcher\", \"searcher\", \"searcher\", \"search…\n$ Clutch_max &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 3, 4, 4, 3, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4,…\n$ floatAge   &lt;dbl&gt; NA, NA, 6, 3, 4, 2, 2, 5, 4, 4, 6, 5, 4, 4, 4, 5, 4, 12, 3,…\n$ ageMethod  &lt;chr&gt; NA, NA, \"float\", \"float\", \"float\", \"float\", \"float\", \"float…\n\n\nSpecies is probably the field we will use to join nest to the species\nOK let’s do it:\nFirst, we need to compute the average of the volume of an egg. We can use the following formula:\n\\(Volume=\\frac{\\Pi}6W^2L\\)\nWhere W is the width and L the length of the egg\nWe can use mutate to do so:\n\neggs_area_df &lt;- eggs_csv %&gt;%\n  mutate(egg_volume = pi/6*Width^2*Length)\n\nNow let’s join this information to the nest table, and average by species\n\nspecies_egg_volume_avg &lt;- left_join(nests_csv, eggs_area_df, by=\"Nest_ID\") %&gt;%\n  group_by(Species) %&gt;%\n  summarise(egg_volume_avg = mean(egg_volume, na.rm = TRUE)) %&gt;%\n  arrange(desc(egg_volume_avg)) %&gt;%\n  drop_na()\n\nspecies_egg_volume_avg\n\n# A tibble: 7 × 2\n  Species egg_volume_avg\n  &lt;chr&gt;            &lt;dbl&gt;\n1 bbpl            33975.\n2 amgp            28545.\n3 rutu            18094.\n4 dunl            11777.\n5 wrsa            10111.\n6 sepl             9903.\n7 reph             8444.\n\n\nIdeally we would like the scientific names…\n\nspecies_egg_area_avg &lt;- species_study %&gt;%\n  inner_join(species_egg_volume_avg, by = join_by(Code == Species)) \n\nspecies_egg_area_avg\n\n# A tibble: 6 × 3\n  Scientific_name         Code  egg_volume_avg\n  &lt;chr&gt;                   &lt;chr&gt;          &lt;dbl&gt;\n1 Calidris alpina         dunl          11777.\n2 Calidris fuscicollis    wrsa          10111.\n3 Charadrius semipalmatus sepl           9903.\n4 Phalaropus fulicarius   reph           8444.\n5 Pluvialis dominica      amgp          28545.\n6 Pluvialis squatarola    bbpl          33975."
  },
  {
    "objectID": "hands-on.html#lets-connect-to-our-first-database",
    "href": "hands-on.html#lets-connect-to-our-first-database",
    "title": "Hands-on DuckDB & dplyr",
    "section": "Let’s connect to our first database",
    "text": "Let’s connect to our first database\n\nLoad the bird database\nThis database has been built from the csv files we just analyzed, so the data should be very similar - note we did not say identical more on this in the last section:\n\nconn &lt;- dbConnect(duckdb::duckdb(), dbdir = \"./data/bird_database.duckdb\", read_only = FALSE)\n\nList all the tables present in the database:\n\ndbListTables(conn)\n\n[1] \"Bird_eggs\"       \"Bird_nests\"      \"Camp_assignment\" \"Personnel\"      \n[5] \"Site\"            \"Species\"        \n\n\nLet’s have a look at the Species table\n\nspecies_db &lt;- tbl(conn, \"Species\")\nspecies_db\n\n# Source:   table&lt;Species&gt; [?? x 4]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1015-azure:R 4.3.3/./data/bird_database.duckdb]\n   Code  Common_name             Scientific_name        Relevance               \n   &lt;chr&gt; &lt;chr&gt;                   &lt;chr&gt;                  &lt;chr&gt;                   \n 1 agsq  Arctic ground squirrel  Spermophilus parryii   Potential predator (egg…\n 2 amcr  American Crow           Corvus brachyrhynchos  Potential predator (avi…\n 3 amgp  American Golden-Plover  Pluvialis dominica     Study species           \n 4 arfo  Arctic fox              Alopex lagopus         Potential predator (mam…\n 5 arte  Arctic Tern             Sterna paradisaea      Incidental monitoring   \n 6 basa  Baird's Sandpiper       Calidris bairdii       Study species           \n 7 bbis  Broad-billed Sandpiper  Calidris falcinellus   Study species           \n 8 bbpl  Black-bellied Plover    Pluvialis squatarola   Study species           \n 9 bbsa  Buff-breasted Sandpiper Calidris subruficollis Study species           \n10 besw  Bewick's Swan           Cygnus columbianus     Incidental monitoring   \n# ℹ more rows\n\n\n\nspecies_db %&gt;%\n  filter(Relevance==\"Study species\") %&gt;%\n  select(Scientific_name) %&gt;%\n  arrange(Scientific_name) %&gt;%\n  head(3)\n\n# Source:     SQL [3 x 1]\n# Database:   DuckDB v0.9.2 [unknown@Linux 6.5.0-1015-azure:R 4.3.3/./data/bird_database.duckdb]\n# Ordered by: Scientific_name\n  Scientific_name   \n  &lt;chr&gt;             \n1 Actitis macularius\n2 Calidris acuminata\n3 Calidris alba     \n\n\nNote that those are not data frames but tables. What dbplyr is actually doing behind the scenes is translating all those dplyr operations into SQL, sending the SQL code to query the database, retrieving results, etc.\n\nHow can I get a “real data frame?”\nYou add collect() to your query.\n\nspecies_db %&gt;%\n  filter(Relevance==\"Study species\") %&gt;%\n  select(Scientific_name) %&gt;%\n  arrange(Scientific_name) %&gt;%\n  head(3) %&gt;% \n  collect()\n\n# A tibble: 3 × 1\n  Scientific_name   \n  &lt;chr&gt;             \n1 Actitis macularius\n2 Calidris acuminata\n3 Calidris alba     \n\n\nNote it means the full query is going to be ran and save in your environment. This might slow things down so you generally want to collect on the smallest data frame you can\n\n\nHow can you see the SQL query equivalent to the tidyverse code? =&gt; show_query()\n\n# Add show_query() to the end to see what SQL it is sending!\nspecies_db %&gt;%\n  filter(Relevance==\"Study species\") %&gt;%\n  select(Scientific_name) %&gt;%\n  arrange(Scientific_name) %&gt;%\n  head(3) %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT Scientific_name\nFROM Species\nWHERE (Relevance = 'Study species')\nORDER BY Scientific_name\nLIMIT 3\n\n\nThis is a great way to start getting familiar with the SQL syntax, because although you can do a lot with dbplyr you can not do everything that SQL can do. So at some point you might want to start using SQL directly.\nHere is how you could run the query using the SQL code directly:\n\n# query the database using SQL\ndbGetQuery(conn, \"SELECT Scientific_name FROM Species WHERE (Relevance = 'Study species') ORDER BY Scientific_name LIMIT 3\")\n\n     Scientific_name\n1 Actitis macularius\n2 Calidris acuminata\n3      Calidris alba\n\n\nYou can do pretty much anything with these quasi-tables, including grouping, summarization, joins, etc.\nLet’s count how many species there are per Relevance categories:\n\nspecies_db %&gt;%\n  group_by(Relevance) %&gt;%\n  summarize(num_species = n())\n\n# Source:   SQL [7 x 2]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1015-azure:R 4.3.3/./data/bird_database.duckdb]\n  Relevance                                num_species\n  &lt;chr&gt;                                          &lt;dbl&gt;\n1 Incidental monitoring                             18\n2 Potential predator (eggs; mammal)                  2\n3 Microtine (alternate prey for predators)           5\n4 Study species                                     41\n5 Potential predator (avian)                        25\n6 Potential predator (mammal)                        6\n7 Study species; potential predator (eggs)           2\n\n\nDoes that code looks familiar? But this time, here is really the query that was used to retrieve this information:\n\nspecies_db %&gt;%\n  group_by(Relevance) %&gt;%\n  summarize(num_species = n()) %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT Relevance, COUNT(*) AS num_species\nFROM Species\nGROUP BY Relevance\n\n\nYou can also create new columns using mutate:\n\nspecies_db %&gt;%\n  mutate(Code = paste(\"X\", Code)) %&gt;%\n  head()\n\n# Source:   SQL [6 x 4]\n# Database: DuckDB v0.9.2 [unknown@Linux 6.5.0-1015-azure:R 4.3.3/./data/bird_database.duckdb]\n  Code   Common_name            Scientific_name       Relevance                 \n  &lt;chr&gt;  &lt;chr&gt;                  &lt;chr&gt;                 &lt;chr&gt;                     \n1 X agsq Arctic ground squirrel Spermophilus parryii  Potential predator (eggs;…\n2 X amcr American Crow          Corvus brachyrhynchos Potential predator (avian)\n3 X amgp American Golden-Plover Pluvialis dominica    Study species             \n4 X arfo Arctic fox             Alopex lagopus        Potential predator (mamma…\n5 X arte Arctic Tern            Sterna paradisaea     Incidental monitoring     \n6 X basa Baird's Sandpiper      Calidris bairdii      Study species             \n\n\nHow does the query looks like?\n\nspecies_db %&gt;%\n  mutate(Code = paste(\"X\", Code)) %&gt;%\n  head() %&gt;%\n  show_query()\n\n&lt;SQL&gt;\nSELECT\n  CONCAT_WS(' ', 'X', Code) AS Code,\n  Common_name,\n  Scientific_name,\n  Relevance\nFROM Species\nLIMIT 6\n\n\n\n\n\n\n\n\nCaution\n\n\n\n****Limitation: no way to add or update data in the database, dbplyr is view only. If you want to add or update data, you’ll need to use the DBI package functions.***\n\n\n\n\n\nAverage egg volume analysis\nLet’s reproduce the egg volume analysis we just did. We can calculate the average bird eggs volume per species directly on the database\n\n# loading all the necessary tables\neggs_db &lt;- tbl(conn, \"Bird_eggs\")\nnests_db &lt;- tbl(conn, \"Bird_nests\")\n\nCompute the volume:\n\n# Compute the egg volume\neggs_area_db &lt;- eggs_db %&gt;%\n  mutate(egg_volume = pi/6*Width^2*Length)\n\nNow let’s join this information to the nest table, and average by species\n\n# Join the egg and nest tables to compute average\nspecies_egg_volume_avg_db &lt;- left_join(nests_db, eggs_area_db, by=\"Nest_ID\") %&gt;%\n  group_by(Species) %&gt;%\n  summarise(egg_volume_avg = mean(egg_volume, na.rm = TRUE)) %&gt;%\n  arrange(desc(egg_volume_avg)) %&gt;% \n  collect() %&gt;%\n  drop_na()\n\nspecies_egg_volume_avg_db\n\n# A tibble: 7 × 2\n  Species egg_volume_avg\n  &lt;chr&gt;            &lt;dbl&gt;\n1 bbpl            33975.\n2 amgp            28545.\n3 rutu            18094.\n4 dunl            11777.\n5 wrsa            10111.\n6 sepl             9903.\n7 reph             8444.\n\n\nWhat does this SQL quert looks like?\n\nspecies_egg_volume_avg_db &lt;- left_join(nests_db, eggs_area_db, by=\"Nest_ID\") %&gt;%\n  group_by(Species) %&gt;%\n  summarise(egg_volume_avg = mean(egg_volume, na.rm = TRUE)) %&gt;%\n  arrange(desc(egg_volume_avg)) %&gt;% \n  show_query()\n\n&lt;SQL&gt;\nSELECT Species, AVG(egg_volume) AS egg_volume_avg\nFROM (\n  SELECT\n    Bird_nests.Book_page AS \"Book_page.x\",\n    Bird_nests.\"Year\" AS \"Year.x\",\n    Bird_nests.Site AS \"Site.x\",\n    Bird_nests.Nest_ID AS Nest_ID,\n    Species,\n    Observer,\n    Date_found,\n    how_found,\n    Clutch_max,\n    floatAge,\n    ageMethod,\n    RHS.Book_page AS \"Book_page.y\",\n    RHS.\"Year\" AS \"Year.y\",\n    RHS.Site AS \"Site.y\",\n    Egg_num,\n    Length,\n    Width,\n    egg_volume\n  FROM Bird_nests\n  LEFT JOIN (\n    SELECT\n      Bird_eggs.*,\n      ((3.14159265358979 / 6.0) * (POW(Width, 2.0))) * Length AS egg_volume\n    FROM Bird_eggs\n  ) RHS\n    ON (Bird_nests.Nest_ID = RHS.Nest_ID)\n) q01\nGROUP BY Species\nORDER BY egg_volume_avg DESC\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhy does the SQL query include the volume computation?\n\n\n\n\nDisconnecting from the database\nBefore we close our session, it is good practice to disconnect from the database first\n\nDBI::dbDisconnect(conn, shutdown = TRUE)"
  },
  {
    "objectID": "hands-on.html#how-did-we-create-this-database",
    "href": "hands-on.html#how-did-we-create-this-database",
    "title": "Hands-on DuckDB & dplyr",
    "section": "How did we create this database",
    "text": "How did we create this database\nYou might be wondering how we created this database from our csv files. Most databases provide functions to import data from csv and other types of files. It is also possible to load data into the database programmatically from within R, one row at a time, using insert statements, but it is more common to load data from csv files. Note that since there is little data modeling within a csv file (the data does not have to be normalized or tidy), and no data type or value constraints can be enforced, a lot things can go wrong. Putting data in a database is thus a great opportunity to implement QA/QC and help you keep your data clean and tidy moving forward as new data are collected.\nTo look at one example, below is the SQL code that was used to create the Bird_eggs table:\n\nCREATE TABLE Bird_eggs (\n    Book_page VARCHAR,\n    Year INTEGER NOT NULL CHECK (Year BETWEEN 1950 AND 2015),\n    Site VARCHAR NOT NULL,\n    FOREIGN KEY (Site) REFERENCES Site (Code),\n    Nest_ID VARCHAR NOT NULL,\n    FOREIGN KEY (Nest_ID) REFERENCES Bird_nests (Nest_ID),\n    Egg_num INTEGER NOT NULL CHECK (Egg_num BETWEEN 1 AND 20),\n    Length FLOAT NOT NULL CHECK (Length &gt; 0 AND Length &lt; 100),\n    Width FLOAT NOT NULL CHECK (Width &gt; 0 AND Width &lt; 100),\n    PRIMARY KEY (Nest_ID, Egg_num)\n);\n\nCOPY Bird_eggs FROM 'ASDN_Bird_eggs.csv' (header TRUE);\n\nDuckDB’s COPY SQL command reads a csv file into a database table. Had we not already created the table in the previous statement, DuckDB would have created it automatically and guessed at column names and data types. But by explicitly declaring the table, we are able to add more characterization to the data. Notable in the above:\n\nNOT NULL indicates that missing values are not allowed.\nConstraints (e.g., Egg_num BETWEEN 1 and 20) express our expectations about the data.\nA FOREIGN KEY declares that a value must refer to an existing value in another table, i.e., it must be a reference.\nA PRIMARY KEY identifies a quantity that should be unique within each row, and that serves as a row identifier.\n\nUnderstand that a table declaration serves as more than documentation; the database actually enforces constraints."
  }
]